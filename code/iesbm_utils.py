'''
@file: iesbm_utils.py
@author: qxliu
@time: 2020/5/20 11:09
'''
# from f_imp import *
import os
import numpy as np
from enum import Enum

CODE_DIR = os.path.dirname(__file__)
ROOT_DIR = os.path.dirname(CODE_DIR)
IN_DIR = os.path.join(ROOT_DIR, 'data', 'in') # iESBM data, include dataset ('in_ds_raw'), dataset by id ('in_ds_parsed'), features ('in_ds_feature'), FER results ('in_ds_fer');
ALGOROOT_DIR = os.path.join(ROOT_DIR, 'data', 'algosumm') # customize data, summaries generated by algorithms to be evaluated
OUT_DIR = os.path.join(ROOT_DIR, 'data', 'out') # output of evaluator, include FSR results ('out_${algo_name}')

class TOPK(Enum):
	top5 = 5;  # lef-side is name, right-side is value
	top10 = 10;

def load_espo_tid(ds_name):
	espo_tid_dict = dict()
	# tid_file = os.path.join(ROOT_DIR, 'data', 'in_ds_parsed', '{}_tids.txt'.format(ds_name))
	tid_file = os.path.join(IN_DIR, 'in_ds_parsed', '{}_tids.txt'.format(ds_name))
	with open(tid_file, 'r', encoding='utf-8') as fin:
		for line in fin:
			items = line.strip().split('\t')
			tid = int(items[0])
			eid = int(items[1])
			isfwd = int(items[2])
			s = items[3].strip()
			p = items[4].strip()
			o = items[5].strip()
			espo_tid_dict[(eid,s,p,o)]=tid
	# if eid==99:#95:#22:#99: #1: # for debug
	# 	print("dkey:",(eid,s,p,o),'val:',tid)
	return espo_tid_dict


def load_eid_desc_tids(ds_name):
	# desc_dir = os.path.join(ROOT_DIR, 'data', 'in_ds_parsed')
	desc_dir = os.path.join(IN_DIR, 'in_ds_parsed')
	desc_file = os.path.join(desc_dir, '{}_desc.txt'.format(ds_name))
	eid_desc_dict = dict()
	with open(desc_file, 'r', encoding='utf-8') as fin:
		for line in fin:
			items = line.strip().split('\t')
			eid = int(items[0])
			desc = eval(items[1])
			assert type(desc)==list
			eid_desc_dict[eid]=desc
	return eid_desc_dict;

def load_eid_ugold_tids(ds_name, topk):
	# summ_dir = os.path.join(ROOT_DIR, 'data', 'in_ds_parsed')
	summ_dir = os.path.join(IN_DIR, 'in_ds_parsed')
	summ_file = os.path.join(summ_dir, '{}_eugold_{}.txt'.format(ds_name,topk.name))
	eid_ugold_dict = dict()
	with open(summ_file, 'r', encoding='utf-8') as fin:
		for line in fin:
			items = line.strip().split('\t')
			eid = int(items[0])
			uid = int(items[1])
			gold = eval(items[2])
			assert type(gold)==list
			# eid_summ_dict[(eid,uid)]=gold
			e_info = eid_ugold_dict.get(eid) if eid in eid_ugold_dict.keys() else dict()
			e_info[uid]=gold
			eid_ugold_dict[eid]=e_info
	return eid_ugold_dict;


def load_eid_fer_dict(fname, ds_name, topk):
	fer_file = os.path.join(IN_DIR, 'in_ds_fer','FER_{}_{}_{}.txt'.format(fname, ds_name, topk.name))
	if not os.path.exists(fer_file):
		raise Exception('FER file not exist! Please check the path or generate FER files by calling iesbm_gen.gen_fer() , fer_path=%s'%fer_file)
	eid_fer_dict = dict()
	with open(fer_file, 'r', encoding='utf-8') as fin:
		for line in fin:
			items = line.strip().split('\t')
			eid = int(items[0])
			fer = float(items[1])
			# ugscore = float(items[2])
			# descsocre = float(items[3])
			eid_fer_dict[eid]=fer
	return eid_fer_dict;


from scipy import stats
from scipy.stats import ttest_1samp
def get_sig_with_1(ratio_items, with_latex=True):
	'''
	two-sided one sample T-test for mean=1:
	Calculates the T-test for the mean of ONE group of scores.
	This is a two-sided test for the null hypothesis that the expected value (mean) of a sample of independent observations a is equal to the given population mean, popmean.
	:param items:
	:return:
	'''
	popmean = 1.0
	t,p = ttest_1samp(ratio_items, popmean=popmean)
	# print('t-p1:',t,p)
	if with_latex:
		mean = np.mean(ratio_items)
		significance = _get_sig_latex(p, mean, popmean)
		return significance
	else:
		return t, p


def get_sig_two_sample_paired(values1, values2, with_latex=True):
	t, p = stats.ttest_rel(values1, values2) # paired (repeated)
	# print('t-p2:',t,p)
	if with_latex:
		mean1 = np.mean(values1)
		mean2 = np.mean(values2)
		significance = _get_sig_latex(p, mean1, mean2)
		return significance
	else:
		return t, p


def _get_sig_latex(p, mean1, mean2):

	significance = '\\tiny{$^\circ$}'  # no significant difference
	if p <= 0.01:
		if mean1 > mean2:  # sys1 is an improvement of sys2
			significance = '\\tiny{$^\\blacktriangle$}'
		else:  # sys1 is lower than sys2
			significance = '\\tiny{$^\\blacktriangledown$}'
	elif p <= 0.05:
		if mean1 > mean2:  # sys1 is an improvement of sys2
			significance = '\\tiny{$^\\vartriangle$}'
		else:  # sys1 is lower than sys2
			significance = '\\tiny{$^\\triangledown$}'
	return significance
